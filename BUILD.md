# Pickrr — Complete Build Documentation
### AI-Ready Production Build Guide
> Read this entire document before writing a single line of code.

---

## 0. What You Are Building

**Pickrr** is a self-hostable web application that sits between Overseerr and the *arr ecosystem. When a user requests media on Overseerr, instead of Radarr/Sonarr automatically picking a torrent, Pickrr intercepts the request, searches Prowlarr for results, and presents them in a UI so an admin (or the user) can manually select which torrent to download. It then sends the selection to qBittorrent and notifies Radarr/Sonarr to import the completed download.

**The full flow:**
```
User → Overseerr (request) → webhook → Pickrr → Prowlarr (search)
→ Admin selects torrent in Pickrr UI → qBittorrent (download)
→ Radarr/Sonarr (import + organize) → Jellyfin (available)
```

---

## 1. Tech Stack — Non-Negotiable

| Layer | Technology | Version |
|---|---|---|
| Framework | Next.js (App Router) | 14.x |
| Language | TypeScript | 5.x |
| Styling | Tailwind CSS | 3.x |
| UI Components | shadcn/ui | latest |
| Database ORM | Prisma | 5.x |
| Database | SQLite | via Prisma |
| Job Queue | BullMQ | 5.x |
| Cache/Queue Broker | Redis (ioredis) | 7.x (Docker) |
| Auth | NextAuth.js | 5.x (Auth.js) |
| HTTP Client | Native fetch (Node 18+) | — |
| Validation | Zod | 3.x |
| Icons | Lucide React | latest |
| Notifications | Sonner (toasts) | latest |
| State Management | Zustand | 4.x |
| Data Fetching | SWR | 2.x |
| Container | Docker + Docker Compose | — |

---

## 2. Complete Project Structure

```
pickrr/
├── .github/
│   └── workflows/
│       ├── ci.yml                    # Lint + type check on PR
│       └── release.yml               # Build + push Docker image to GHCR
├── prisma/
│   ├── schema.prisma                 # Full DB schema
│   └── migrations/                   # Auto-generated by Prisma
├── public/
│   └── logo.svg                      # Pickrr logo
├── src/
│   ├── app/
│   │   ├── layout.tsx                # Root layout (fonts, providers)
│   │   ├── globals.css               # Tailwind base
│   │   ├── (auth)/
│   │   │   ├── layout.tsx            # Auth layout (centered card)
│   │   │   └── login/
│   │   │       └── page.tsx          # Login page
│   │   ├── (dashboard)/
│   │   │   ├── layout.tsx            # Dashboard layout (sidebar + header)
│   │   │   ├── page.tsx              # Home: pending requests
│   │   │   ├── search/
│   │   │   │   └── page.tsx          # Manual search page
│   │   │   ├── history/
│   │   │   │   └── page.tsx          # Download history
│   │   │   ├── downloads/
│   │   │   │   └── page.tsx          # Active downloads with progress
│   │   │   └── settings/
│   │   │       └── page.tsx          # Admin settings (API keys etc.)
│   │   └── api/
│   │       ├── auth/
│   │       │   └── [...nextauth]/
│   │       │       └── route.ts      # NextAuth handler
│   │       ├── webhook/
│   │       │   └── overseerr/
│   │       │       └── route.ts      # Overseerr webhook receiver
│   │       ├── requests/
│   │       │   ├── route.ts          # GET all pending requests
│   │       │   └── [id]/
│   │       │       └── route.ts      # GET single request details
│   │       ├── search/
│   │       │   └── route.ts          # GET search Prowlarr
│   │       ├── download/
│   │       │   └── route.ts          # POST send to qBittorrent
│   │       ├── downloads/
│   │       │   └── route.ts          # GET active download progress from qBit
│   │       ├── history/
│   │       │   └── route.ts          # GET completed downloads
│   │       └── settings/
│   │           └── route.ts          # GET/POST app settings
│   ├── components/
│   │   ├── ui/                       # shadcn/ui components (auto-generated)
│   │   ├── layout/
│   │   │   ├── Sidebar.tsx
│   │   │   ├── Header.tsx
│   │   │   └── Providers.tsx         # SessionProvider, SWR, Sonner
│   │   ├── requests/
│   │   │   ├── RequestCard.tsx       # Single pending request card
│   │   │   ├── RequestList.tsx       # List of pending requests
│   │   │   └── TorrentSelectModal.tsx # Modal with torrent results table
│   │   ├── search/
│   │   │   ├── SearchBar.tsx
│   │   │   └── SearchResults.tsx
│   │   ├── downloads/
│   │   │   ├── DownloadCard.tsx      # Active download with progress bar
│   │   │   └── DownloadList.tsx
│   │   ├── history/
│   │   │   └── HistoryTable.tsx
│   │   └── settings/
│   │       └── SettingsForm.tsx
│   ├── services/
│   │   ├── prowlarr.ts               # Prowlarr API client
│   │   ├── qbittorrent.ts            # qBittorrent Web API client
│   │   ├── radarr.ts                 # Radarr API client
│   │   ├── sonarr.ts                 # Sonarr API client
│   │   ├── overseerr.ts              # Overseerr API client
│   │   └── tmdb.ts                   # TMDB metadata client
│   ├── lib/
│   │   ├── db.ts                     # Prisma client singleton
│   │   ├── queue.ts                  # BullMQ queue + worker setup
│   │   ├── auth.ts                   # NextAuth config
│   │   ├── settings.ts               # Settings helper (read from DB)
│   │   └── utils.ts                  # cn(), formatBytes(), formatETA() etc.
│   ├── workers/
│   │   └── webhook.worker.ts         # BullMQ worker: process webhook jobs
│   ├── types/
│   │   ├── prowlarr.ts               # Prowlarr API response types
│   │   ├── qbittorrent.ts            # qBit API response types
│   │   ├── overseerr.ts              # Overseerr webhook payload types
│   │   └── index.ts                  # Shared app types
│   └── hooks/
│       ├── useRequests.ts            # SWR hook for pending requests
│       ├── useDownloads.ts           # SWR hook for active downloads (polling)
│       └── useSearch.ts              # SWR hook for search results
├── .env.example
├── .env.local                        # gitignored
├── .eslintrc.json
├── .gitignore
├── Dockerfile
├── docker-compose.yml
├── next.config.ts
├── package.json
├── tailwind.config.ts
├── tsconfig.json
└── README.md
```

---

## 3. Database Schema (Prisma — Copy Exactly)

**File: `prisma/schema.prisma`**

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Request {
  id              String    @id @default(cuid())
  overseerrId     Int       @unique
  tmdbId          Int
  mediaType       String    // "movie" | "tv"
  title           String
  year            Int?
  posterPath      String?
  overview        String?
  status          String    @default("pending")
  // pending | searching | awaiting_selection | selected | downloading | done | failed
  requestedBy     String
  requestedAt     DateTime  @default(now())
  selectedTorrent Torrent?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

model Torrent {
  id          String   @id @default(cuid())
  requestId   String   @unique
  request     Request  @relation(fields: [requestId], references: [id])
  title       String
  indexer     String
  size        BigInt
  seeders     Int
  leechers    Int
  infoUrl     String?
  downloadUrl String
  magnetUrl   String?
  qbitHash    String?
  selectedAt  DateTime @default(now())
  selectedBy  String
}

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String
  updatedAt DateTime @updatedAt
}

model User {
  id          String   @id @default(cuid())
  username    String   @unique
  password    String   // bcrypt hashed
  role        String   @default("viewer") // "admin" | "selector" | "viewer"
  createdAt   DateTime @default(now())
}
```

---

## 4. Environment Variables

**File: `.env.example`** (copy to `.env.local` for dev, `.env` for prod)

```env
# ─── App ────────────────────────────────────────────────────
DATABASE_URL="file:/app/data/pickrr.db"
NEXTAUTH_SECRET="generate-with-openssl-rand-base64-32"
NEXTAUTH_URL="http://localhost:3000"
WEBHOOK_SECRET="any-random-string-shared-with-overseerr"

# ─── Redis ──────────────────────────────────────────────────
REDIS_URL="redis://localhost:6379"

# ─── Prowlarr ───────────────────────────────────────────────
PROWLARR_URL="http://prowlarr:9696"
PROWLARR_API_KEY=""

# ─── qBittorrent ────────────────────────────────────────────
QBIT_URL="http://qbittorrent:8080"
QBIT_USERNAME="admin"
QBIT_PASSWORD=""

# ─── Radarr ─────────────────────────────────────────────────
RADARR_URL="http://radarr:7878"
RADARR_API_KEY=""

# ─── Sonarr ─────────────────────────────────────────────────
SONARR_URL="http://sonarr:8989"
SONARR_API_KEY=""

# ─── Overseerr ──────────────────────────────────────────────
OVERSEERR_URL="http://overseerr:5055"
OVERSEERR_API_KEY=""

# ─── TMDB ───────────────────────────────────────────────────
TMDB_API_KEY=""
TMDB_BASE_URL="https://api.themoviedb.org/3"
TMDB_IMAGE_BASE="https://image.tmdb.org/t/p/w500"

# ─── Download Paths ─────────────────────────────────────────
MOVIES_SAVE_PATH="/downloads/movies"
TV_SAVE_PATH="/downloads/tv"

# ─── Auto-select Fallback ───────────────────────────────────
# Auto-grab top result after X hours if no one selects (0 = disabled)
AUTO_SELECT_HOURS="0"
```

---

## 5. Complete Service Implementations

### 5.1 Prowlarr Service
**File: `src/services/prowlarr.ts`**

```typescript
import type { ProwlarrResult, ProwlarrSearchResponse } from '@/types/prowlarr';

const getProwlarrConfig = () => ({
  url: process.env.PROWLARR_URL!,
  apiKey: process.env.PROWLARR_API_KEY!,
});

export async function searchProwlarr(
  query: string,
  type: 'movie' | 'tv',
  limit = 50
): Promise<ProwlarrResult[]> {
  const { url, apiKey } = getProwlarrConfig();

  const params = new URLSearchParams({
    query,
    type: type === 'movie' ? 'movie' : 'tvsearch',
    limit: limit.toString(),
  });

  const res = await fetch(`${url}/api/v1/search?${params}`, {
    headers: {
      'X-Api-Key': apiKey,
      'Content-Type': 'application/json',
    },
    next: { revalidate: 0 }, // never cache search results
  });

  if (!res.ok) {
    throw new Error(`Prowlarr search failed: ${res.status} ${res.statusText}`);
  }

  const data: ProwlarrSearchResponse = await res.json();

  // Normalize and sort by seeders descending
  return data
    .map((item) => ({
      guid: item.guid,
      title: item.title,
      indexer: item.indexer,
      indexerId: item.indexerId,
      size: item.size,
      seeders: item.seeders ?? 0,
      leechers: item.leechers ?? 0,
      infoUrl: item.infoUrl ?? null,
      downloadUrl: item.downloadUrl ?? null,
      magnetUrl: item.magnetUrl ?? null,
      publishDate: item.publishDate,
    }))
    .sort((a, b) => b.seeders - a.seeders);
}

export async function testProwlarrConnection(): Promise<boolean> {
  try {
    const { url, apiKey } = getProwlarrConfig();
    const res = await fetch(`${url}/api/v1/system/status`, {
      headers: { 'X-Api-Key': apiKey },
    });
    return res.ok;
  } catch {
    return false;
  }
}
```

### 5.2 qBittorrent Service
**File: `src/services/qbittorrent.ts`**

```typescript
import type { QbitTorrent } from '@/types/qbittorrent';

let qbitCookie: string | null = null;
let cookieExpiry: number = 0;

const getQbitConfig = () => ({
  url: process.env.QBIT_URL!,
  username: process.env.QBIT_USERNAME!,
  password: process.env.QBIT_PASSWORD!,
});

async function getAuthCookie(): Promise<string> {
  if (qbitCookie && Date.now() < cookieExpiry) return qbitCookie;

  const { url, username, password } = getQbitConfig();

  const res = await fetch(`${url}/api/v2/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
    body: new URLSearchParams({ username, password }),
  });

  const cookie = res.headers.get('set-cookie');
  if (!cookie) throw new Error('qBittorrent auth failed — check credentials');

  qbitCookie = cookie.split(';')[0];
  cookieExpiry = Date.now() + 3600 * 1000; // 1 hour
  return qbitCookie;
}

export async function addTorrentByUrl(
  downloadUrl: string,
  savePath: string,
  tags: string[] = ['pickrr']
): Promise<void> {
  const { url } = getQbitConfig();
  const cookie = await getAuthCookie();

  const form = new URLSearchParams({
    urls: downloadUrl,
    savepath: savePath,
    tags: tags.join(','),
    category: 'pickrr',
  });

  const res = await fetch(`${url}/api/v2/torrents/add`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      Cookie: cookie,
    },
    body: form,
  });

  if (!res.ok) throw new Error(`qBit add torrent failed: ${res.status}`);
}

export async function addTorrentByMagnet(
  magnetUrl: string,
  savePath: string
): Promise<void> {
  return addTorrentByUrl(magnetUrl, savePath);
}

export async function getTorrentsByHash(hashes: string[]): Promise<QbitTorrent[]> {
  const { url } = getQbitConfig();
  const cookie = await getAuthCookie();

  const res = await fetch(
    `${url}/api/v2/torrents/info?hashes=${hashes.join('|')}`,
    { headers: { Cookie: cookie } }
  );

  if (!res.ok) return [];
  return res.json();
}

export async function getActiveTorrents(): Promise<QbitTorrent[]> {
  const { url } = getQbitConfig();
  const cookie = await getAuthCookie();

  const res = await fetch(
    `${url}/api/v2/torrents/info?filter=active&category=pickrr`,
    { headers: { Cookie: cookie } }
  );

  if (!res.ok) return [];
  return res.json();
}

export async function getTorrentHashByName(name: string): Promise<string | null> {
  const { url } = getQbitConfig();
  const cookie = await getAuthCookie();

  const res = await fetch(`${url}/api/v2/torrents/info`, {
    headers: { Cookie: cookie },
  });

  if (!res.ok) return null;
  const torrents: QbitTorrent[] = await res.json();
  const match = torrents.find((t) => t.name.includes(name));
  return match?.hash ?? null;
}
```

### 5.3 Radarr Service
**File: `src/services/radarr.ts`**

```typescript
const getRadarrConfig = () => ({
  url: process.env.RADARR_URL!,
  apiKey: process.env.RADARR_API_KEY!,
});

export async function notifyRadarrDownloadComplete(tmdbId: number): Promise<void> {
  const { url, apiKey } = getRadarrConfig();

  // Trigger manual import scan
  await fetch(`${url}/api/v3/command`, {
    method: 'POST',
    headers: {
      'X-Api-Key': apiKey,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ name: 'DownloadedMoviesScan' }),
  });
}

export async function getRadarrMovie(tmdbId: number) {
  const { url, apiKey } = getRadarrConfig();

  const res = await fetch(`${url}/api/v3/movie?tmdbId=${tmdbId}`, {
    headers: { 'X-Api-Key': apiKey },
  });

  if (!res.ok) return null;
  const movies = await res.json();
  return movies[0] ?? null;
}

export async function testRadarrConnection(): Promise<boolean> {
  try {
    const { url, apiKey } = getRadarrConfig();
    const res = await fetch(`${url}/api/v3/system/status`, {
      headers: { 'X-Api-Key': apiKey },
    });
    return res.ok;
  } catch {
    return false;
  }
}
```

### 5.4 Sonarr Service
**File: `src/services/sonarr.ts`**

```typescript
const getSonarrConfig = () => ({
  url: process.env.SONARR_URL!,
  apiKey: process.env.SONARR_API_KEY!,
});

export async function notifySonarrDownloadComplete(): Promise<void> {
  const { url, apiKey } = getSonarrConfig();

  await fetch(`${url}/api/v3/command`, {
    method: 'POST',
    headers: {
      'X-Api-Key': apiKey,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ name: 'DownloadedEpisodesScan' }),
  });
}

export async function testSonarrConnection(): Promise<boolean> {
  try {
    const { url, apiKey } = getSonarrConfig();
    const res = await fetch(`${url}/api/v3/system/status`, {
      headers: { 'X-Api-Key': apiKey },
    });
    return res.ok;
  } catch {
    return false;
  }
}
```

### 5.5 TMDB Service
**File: `src/services/tmdb.ts`**

```typescript
const TMDB_BASE = process.env.TMDB_BASE_URL ?? 'https://api.themoviedb.org/3';
const TMDB_IMAGE = process.env.TMDB_IMAGE_BASE ?? 'https://image.tmdb.org/t/p/w500';

export interface TMDBMedia {
  tmdbId: number;
  title: string;
  year: number | null;
  overview: string;
  posterUrl: string | null;
  backdropUrl: string | null;
  rating: number;
  mediaType: 'movie' | 'tv';
}

export async function getTMDBMetadata(
  tmdbId: number,
  mediaType: 'movie' | 'tv'
): Promise<TMDBMedia | null> {
  try {
    const endpoint = mediaType === 'movie' ? 'movie' : 'tv';
    const res = await fetch(
      `${TMDB_BASE}/${endpoint}/${tmdbId}?api_key=${process.env.TMDB_API_KEY}`,
      { next: { revalidate: 86400 } } // cache 24h
    );

    if (!res.ok) return null;
    const data = await res.json();

    const title = mediaType === 'movie' ? data.title : data.name;
    const releaseDate = mediaType === 'movie' ? data.release_date : data.first_air_date;
    const year = releaseDate ? new Date(releaseDate).getFullYear() : null;

    return {
      tmdbId,
      title,
      year,
      overview: data.overview ?? '',
      posterUrl: data.poster_path ? `${TMDB_IMAGE}${data.poster_path}` : null,
      backdropUrl: data.backdrop_path
        ? `${TMDB_IMAGE}${data.backdrop_path}`
        : null,
      rating: data.vote_average ?? 0,
      mediaType,
    };
  } catch {
    return null;
  }
}
```

---

## 6. BullMQ Queue Setup

**File: `src/lib/queue.ts`**

```typescript
import { Queue, Worker, Job } from 'bullmq';
import IORedis from 'ioredis';

const connection = new IORedis(process.env.REDIS_URL!, {
  maxRetriesPerRequest: null,
});

export const webhookQueue = new Queue('webhook-jobs', { connection });

export interface WebhookJobData {
  overseerrId: number;
  tmdbId: number;
  mediaType: 'movie' | 'tv';
  title: string;
  requestedBy: string;
}

export async function enqueueWebhookJob(data: WebhookJobData) {
  await webhookQueue.add('process-request', data, {
    attempts: 3,
    backoff: { type: 'exponential', delay: 5000 },
  });
}
```

**File: `src/workers/webhook.worker.ts`**

```typescript
import { Worker, Job } from 'bullmq';
import IORedis from 'ioredis';
import { db } from '@/lib/db';
import { getTMDBMetadata } from '@/services/tmdb';
import type { WebhookJobData } from '@/lib/queue';

const connection = new IORedis(process.env.REDIS_URL!, {
  maxRetriesPerRequest: null,
});

const worker = new Worker<WebhookJobData>(
  'webhook-jobs',
  async (job: Job<WebhookJobData>) => {
    const { overseerrId, tmdbId, mediaType, title, requestedBy } = job.data;

    // Fetch TMDB metadata
    const meta = await getTMDBMetadata(tmdbId, mediaType);

    // Upsert request in DB
    await db.request.upsert({
      where: { overseerrId },
      create: {
        overseerrId,
        tmdbId,
        mediaType,
        title: meta?.title ?? title,
        year: meta?.year ?? null,
        posterPath: meta?.posterUrl ?? null,
        overview: meta?.overview ?? null,
        status: 'awaiting_selection',
        requestedBy,
      },
      update: {
        status: 'awaiting_selection',
      },
    });
  },
  { connection }
);

worker.on('failed', (job, err) => {
  console.error(`Job ${job?.id} failed:`, err.message);
});

export default worker;
```

---

## 7. API Routes — Complete Implementation

### 7.1 Overseerr Webhook
**File: `src/app/api/webhook/overseerr/route.ts`**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';
import { enqueueWebhookJob } from '@/lib/queue';
import type { OverseerrWebhookPayload } from '@/types/overseerr';

const SUPPORTED_EVENTS = ['MEDIA_APPROVED', 'MEDIA_AUTO_APPROVED'];

export async function POST(req: NextRequest) {
  // Validate webhook secret
  const secret = req.headers.get('x-webhook-secret');
  if (secret !== process.env.WEBHOOK_SECRET) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  let body: OverseerrWebhookPayload;
  try {
    body = await req.json();
  } catch {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
  }

  // Only handle approval events
  if (!SUPPORTED_EVENTS.includes(body.notification_type)) {
    return NextResponse.json({ ok: true, skipped: true });
  }

  // Enqueue for async processing
  await enqueueWebhookJob({
    overseerrId: body.request.id,
    tmdbId: body.media.tmdbId,
    mediaType: body.media.media_type,
    title: body.subject ?? 'Unknown',
    requestedBy: body.request.requestedBy_username ?? 'unknown',
  });

  return NextResponse.json({ ok: true });
}
```

### 7.2 Search Route
**File: `src/app/api/search/route.ts`**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { searchProwlarr } from '@/services/prowlarr';
import { z } from 'zod';

const searchSchema = z.object({
  query: z.string().min(1),
  type: z.enum(['movie', 'tv']),
  limit: z.coerce.number().min(1).max(100).default(50),
});

export async function GET(req: NextRequest) {
  const session = await auth();
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const { searchParams } = new URL(req.url);
  const parsed = searchSchema.safeParse({
    query: searchParams.get('query'),
    type: searchParams.get('type'),
    limit: searchParams.get('limit'),
  });

  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }

  try {
    const results = await searchProwlarr(parsed.data.query, parsed.data.type, parsed.data.limit);
    return NextResponse.json({ results, total: results.length });
  } catch (err: any) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
```

### 7.3 Download Route
**File: `src/app/api/download/route.ts`**

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { db } from '@/lib/db';
import { addTorrentByUrl, addTorrentByMagnet } from '@/services/qbittorrent';
import { notifyRadarrDownloadComplete } from '@/services/radarr';
import { notifySonarrDownloadComplete } from '@/services/sonarr';
import { z } from 'zod';

const downloadSchema = z.object({
  requestId: z.string(),
  title: z.string(),
  indexer: z.string(),
  size: z.number(),
  seeders: z.number(),
  leechers: z.number(),
  downloadUrl: z.string().url().nullable(),
  magnetUrl: z.string().nullable(),
  infoUrl: z.string().nullable(),
});

export async function POST(req: NextRequest) {
  const session = await auth();
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const body = await req.json();
  const parsed = downloadSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json({ error: parsed.error.flatten() }, { status: 400 });
  }

  const { requestId, downloadUrl, magnetUrl, ...torrentData } = parsed.data;

  // Fetch the request to get mediaType + tmdbId
  const request = await db.request.findUnique({ where: { id: requestId } });
  if (!request) return NextResponse.json({ error: 'Request not found' }, { status: 404 });

  const savePath =
    request.mediaType === 'movie'
      ? process.env.MOVIES_SAVE_PATH!
      : process.env.TV_SAVE_PATH!;

  try {
    // Send to qBittorrent
    if (downloadUrl) {
      await addTorrentByUrl(downloadUrl, savePath);
    } else if (magnetUrl) {
      await addTorrentByMagnet(magnetUrl, savePath);
    } else {
      return NextResponse.json({ error: 'No downloadUrl or magnetUrl' }, { status: 400 });
    }

    // Save selection to DB
    await db.torrent.create({
      data: {
        requestId,
        title: torrentData.title,
        indexer: torrentData.indexer,
        size: BigInt(torrentData.size),
        seeders: torrentData.seeders,
        leechers: torrentData.leechers,
        downloadUrl: downloadUrl ?? '',
        magnetUrl: magnetUrl ?? null,
        infoUrl: torrentData.infoUrl ?? null,
        selectedBy: session.user?.name ?? 'admin',
      },
    });

    // Update request status
    await db.request.update({
      where: { id: requestId },
      data: { status: 'downloading' },
    });

    // Notify arr services
    if (request.mediaType === 'movie') {
      await notifyRadarrDownloadComplete(request.tmdbId);
    } else {
      await notifySonarrDownloadComplete();
    }

    return NextResponse.json({ ok: true });
  } catch (err: any) {
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}
```

### 7.4 Requests Route
**File: `src/app/api/requests/route.ts`**

```typescript
import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { db } from '@/lib/db';

export async function GET() {
  const session = await auth();
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const requests = await db.request.findMany({
    where: { status: { in: ['pending', 'searching', 'awaiting_selection'] } },
    include: { selectedTorrent: true },
    orderBy: { createdAt: 'desc' },
  });

  // Serialize BigInt
  return NextResponse.json(
    requests.map((r) => ({
      ...r,
      selectedTorrent: r.selectedTorrent
        ? { ...r.selectedTorrent, size: r.selectedTorrent.size.toString() }
        : null,
    }))
  );
}
```

### 7.5 Active Downloads Route
**File: `src/app/api/downloads/route.ts`**

```typescript
import { NextResponse } from 'next/server';
import { auth } from '@/lib/auth';
import { getActiveTorrents } from '@/services/qbittorrent';
import { db } from '@/lib/db';

export async function GET() {
  const session = await auth();
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const [qbitTorrents, dbTorrents] = await Promise.all([
    getActiveTorrents(),
    db.torrent.findMany({
      include: { request: true },
      orderBy: { selectedAt: 'desc' },
    }),
  ]);

  // Mark completed requests as done
  for (const qbit of qbitTorrents) {
    if (qbit.progress === 1) {
      const dbTorrent = dbTorrents.find(
        (t) => t.qbitHash === qbit.hash || t.title === qbit.name
      );
      if (dbTorrent && dbTorrent.request.status === 'downloading') {
        await db.request.update({
          where: { id: dbTorrent.requestId },
          data: { status: 'done' },
        });
      }
    }
  }

  return NextResponse.json(
    qbitTorrents.map((t) => ({
      hash: t.hash,
      name: t.name,
      progress: t.progress,
      dlspeed: t.dlspeed,
      eta: t.eta,
      size: t.size.toString(),
      state: t.state,
      num_seeds: t.num_seeds,
    }))
  );
}
```

---

## 8. TypeScript Types

**File: `src/types/prowlarr.ts`**

```typescript
export interface ProwlarrResult {
  guid: string;
  title: string;
  indexer: string;
  indexerId: number;
  size: number;
  seeders: number;
  leechers: number;
  infoUrl: string | null;
  downloadUrl: string | null;
  magnetUrl: string | null;
  publishDate: string;
}

export type ProwlarrSearchResponse = Array<{
  guid: string;
  title: string;
  indexer: string;
  indexerId: number;
  size: number;
  seeders?: number;
  leechers?: number;
  infoUrl?: string;
  downloadUrl?: string;
  magnetUrl?: string;
  publishDate: string;
}>;
```

**File: `src/types/qbittorrent.ts`**

```typescript
export interface QbitTorrent {
  hash: string;
  name: string;
  size: number;
  progress: number;        // 0.0 to 1.0
  dlspeed: number;         // bytes/sec
  upspeed: number;
  num_seeds: number;
  num_leechs: number;
  eta: number;             // seconds, 8640000 = infinity
  state: string;           // 'downloading' | 'uploading' | 'stalledDL' | 'pausedDL' etc.
  save_path: string;
  category: string;
  tags: string;
  added_on: number;        // unix timestamp
  completion_on: number;
}
```

**File: `src/types/overseerr.ts`**

```typescript
export interface OverseerrWebhookPayload {
  notification_type: string;
  subject: string;
  message?: string;
  media: {
    media_type: 'movie' | 'tv';
    tmdbId: number;
    status: string;
  };
  request: {
    id: number;
    requestedBy_username?: string;
    requestedBy_email?: string;
  };
}
```

---

## 9. Auth Setup

**File: `src/lib/auth.ts`**

```typescript
import NextAuth from 'next-auth';
import Credentials from 'next-auth/providers/credentials';
import { db } from '@/lib/db';
import bcrypt from 'bcryptjs';

export const { handlers, auth, signIn, signOut } = NextAuth({
  providers: [
    Credentials({
      credentials: {
        username: { label: 'Username', type: 'text' },
        password: { label: 'Password', type: 'password' },
      },
      async authorize(credentials) {
        if (!credentials?.username || !credentials?.password) return null;

        const user = await db.user.findUnique({
          where: { username: credentials.username as string },
        });

        if (!user) return null;

        const valid = await bcrypt.compare(
          credentials.password as string,
          user.password
        );

        if (!valid) return null;

        return { id: user.id, name: user.username, role: user.role };
      },
    }),
  ],
  callbacks: {
    async jwt({ token, user }) {
      if (user) token.role = (user as any).role;
      return token;
    },
    async session({ session, token }) {
      if (session.user) (session.user as any).role = token.role;
      return session;
    },
  },
  pages: {
    signIn: '/login',
  },
});
```

**File: `src/lib/db.ts`**

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as { prisma: PrismaClient };

export const db = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = db;
```

---

## 10. Key UI Components

### 10.1 TorrentSelectModal
**File: `src/components/requests/TorrentSelectModal.tsx`**

This is the most important component. It should:
- Accept `requestId`, `title`, `mediaType`, `tmdbId` as props
- On open, call `GET /api/search?query={title}&type={mediaType}`
- Show a loading skeleton while searching
- Display results in a table with columns:
  - **Indexer** (badge with color per indexer)
  - **Title** (truncated, max 60 chars)
  - **Size** (formatted: "2.1 GB")
  - **Seeds** (green if >50, yellow if >10, red if <10)
  - **Leech**
  - **Action** button: "↓ Grab"
- Clicking Grab calls `POST /api/download` with the selected result
- Show toast on success/error
- Allow filtering by indexer (dropdown)
- Allow sorting by: Seeders (default), Size, Title

### 10.2 RequestCard
**File: `src/components/requests/RequestCard.tsx`**

Shows:
- TMDB poster (left side, w-24)
- Title + year
- Media type badge (Movie/TV)
- Requested by + time ago
- Status badge
- "Select Torrent" button that opens TorrentSelectModal
- If status is `downloading`: show small progress indicator

### 10.3 DownloadCard
**File: `src/components/downloads/DownloadCard.tsx`**

Shows:
- Torrent name
- Progress bar (use shadcn Progress component)
- Speed: "↓ 8.4 MB/s"
- ETA: "~2 mins" (handle eta = 8640000 as "∞")
- Seeds count
- State badge

---

## 11. SWR Hooks

**File: `src/hooks/useRequests.ts`**

```typescript
import useSWR from 'swr';

const fetcher = (url: string) => fetch(url).then((r) => r.json());

export function useRequests() {
  const { data, error, isLoading, mutate } = useSWR('/api/requests', fetcher, {
    refreshInterval: 10000, // poll every 10s for new requests
  });

  return {
    requests: data ?? [],
    isLoading,
    isError: !!error,
    mutate,
  };
}
```

**File: `src/hooks/useDownloads.ts`**

```typescript
import useSWR from 'swr';

const fetcher = (url: string) => fetch(url).then((r) => r.json());

export function useDownloads() {
  const { data, error, isLoading } = useSWR('/api/downloads', fetcher, {
    refreshInterval: 3000, // poll every 3s for progress updates
  });

  return {
    downloads: data ?? [],
    isLoading,
    isError: !!error,
  };
}
```

---

## 12. Utility Functions

**File: `src/lib/utils.ts`**

```typescript
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

export function formatBytes(bytes: number | string): string {
  const b = typeof bytes === 'string' ? parseInt(bytes) : bytes;
  if (b === 0) return '0 B';
  const k = 1024;
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(b) / Math.log(k));
  return `${parseFloat((b / Math.pow(k, i)).toFixed(1))} ${sizes[i]}`;
}

export function formatSpeed(bytesPerSec: number): string {
  return `${formatBytes(bytesPerSec)}/s`;
}

export function formatETA(seconds: number): string {
  if (seconds >= 8640000 || seconds < 0) return '∞';
  if (seconds < 60) return `${seconds}s`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
  return `${Math.floor(seconds / 3600)}h ${Math.floor((seconds % 3600) / 60)}m`;
}

export function timeAgo(date: Date | string): string {
  const d = new Date(date);
  const diff = (Date.now() - d.getTime()) / 1000;
  if (diff < 60) return 'just now';
  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
  if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
  return `${Math.floor(diff / 86400)}d ago`;
}

export function truncate(str: string, maxLen: number): string {
  return str.length > maxLen ? `${str.slice(0, maxLen)}...` : str;
}
```

---

## 13. Docker Setup

**File: `Dockerfile`**

```dockerfile
FROM node:20-alpine AS base

# Install dependencies only when needed
FROM base AS deps
RUN apk add --no-cache libc6-compat openssl
WORKDIR /app
COPY package.json package-lock.json* ./
RUN npm ci

# Rebuild the source code only when needed
FROM base AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN npx prisma generate
RUN npm run build

# Production image
FROM base AS runner
WORKDIR /app
ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nextjs

COPY --from=builder /app/public ./public
COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static
COPY --from=builder /app/prisma ./prisma
COPY --from=builder /app/node_modules/.prisma ./node_modules/.prisma
COPY --from=builder /app/node_modules/@prisma ./node_modules/@prisma

# Startup script
COPY docker-entrypoint.sh ./
RUN chmod +x docker-entrypoint.sh

RUN mkdir -p /app/data && chown nextjs:nodejs /app/data

USER nextjs

EXPOSE 3000
ENV PORT=3000
ENV HOSTNAME="0.0.0.0"

ENTRYPOINT ["./docker-entrypoint.sh"]
```

**File: `docker-entrypoint.sh`**

```bash
#!/bin/sh
set -e

echo "Running database migrations..."
npx prisma migrate deploy

echo "Starting worker..."
node src/workers/webhook.worker.js &

echo "Starting Next.js..."
exec node server.js
```

**File: `docker-compose.yml`** (for self-hosters)

```yaml
services:
  pickrr:
    image: ghcr.io/yourusername/pickrr:latest
    restart: unless-stopped
    expose:
      - "3000"
    volumes:
      - /opt/pickrr/data:/app/data
    env_file:
      - .env
    depends_on:
      redis:
        condition: service_healthy
    networks:
      - dokploy-network

  redis:
    image: redis:7-alpine
    restart: unless-stopped
    volumes:
      - /opt/pickrr/redis:/data
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5
    networks:
      - dokploy-network

networks:
  dokploy-network:
    external: true
```

**File: `next.config.ts`**

```typescript
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  output: 'standalone',
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'image.tmdb.org',
      },
    ],
  },
};

export default nextConfig;
```

---

## 14. Package.json

```json
{
  "name": "pickrr",
  "version": "0.1.0",
  "private": false,
  "license": "MIT",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "db:push": "prisma db push",
    "db:migrate": "prisma migrate dev",
    "db:studio": "prisma studio",
    "worker": "tsx src/workers/webhook.worker.ts"
  },
  "dependencies": {
    "@prisma/client": "^5.0.0",
    "bcryptjs": "^2.4.3",
    "bullmq": "^5.0.0",
    "clsx": "^2.1.0",
    "ioredis": "^5.3.2",
    "lucide-react": "^0.400.0",
    "next": "14.2.0",
    "next-auth": "5.0.0-beta.19",
    "react": "^18",
    "react-dom": "^18",
    "sonner": "^1.5.0",
    "swr": "^2.2.5",
    "tailwind-merge": "^2.3.0",
    "zod": "^3.23.0",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.0",
    "prisma": "^5.0.0",
    "tailwindcss": "^3.4.0",
    "tsx": "^4.7.0",
    "typescript": "^5"
  }
}
```

---

## 15. GitHub Actions CI/CD

**File: `.github/workflows/release.yml`**

```yaml
name: Build and Push Docker Image

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ghcr.io/${{ github.repository }}:latest
            ghcr.io/${{ github.repository }}:${{ github.ref_name }}
```

---

## 16. Overseerr Configuration

After deploying Pickrr, configure Overseerr:

1. Go to **Overseerr → Settings → Notifications → Webhook**
2. Add new webhook:
   - **Webhook URL:** `https://pickrr.yourdomain.com/api/webhook/overseerr`
   - **Secret:** same value as `WEBHOOK_SECRET` in your `.env`
   - **Enable:** MEDIA_APPROVED, MEDIA_AUTO_APPROVED
3. **Disable auto-search in Radarr/Sonarr:**
   - Radarr → Settings → General → uncheck "Automatically Search"
   - Sonarr → Settings → General → uncheck "Automatically Search"
   This prevents Radarr/Sonarr from auto-grabbing while Pickrr handles selection.

---

## 17. First-Run Setup

On first run, create the admin user via a setup script or seed:

**File: `prisma/seed.ts`**

```typescript
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const db = new PrismaClient();

async function main() {
  const existing = await db.user.findUnique({ where: { username: 'admin' } });
  if (existing) {
    console.log('Admin user already exists');
    return;
  }

  const password = process.env.ADMIN_PASSWORD ?? 'changeme';
  const hash = await bcrypt.hash(password, 12);

  await db.user.create({
    data: {
      username: 'admin',
      password: hash,
      role: 'admin',
    },
  });

  console.log('Admin user created. Username: admin, Password:', password);
}

main().finally(() => db.$disconnect());
```

Add to `package.json`:
```json
"prisma": {
  "seed": "tsx prisma/seed.ts"
}
```

---

## 18. UI Design Guidelines

- **Color scheme:** Dark theme by default. Background `gray-950`, cards `gray-900`, borders `gray-800`
- **Accent color:** Indigo (`indigo-500` / `indigo-600`)
- **Seeders color coding:** `green-400` if ≥50, `yellow-400` if ≥10, `red-400` if <10
- **Status badges:**
  - `pending` → gray
  - `awaiting_selection` → yellow (pulsing dot)
  - `downloading` → blue (animated)
  - `done` → green
  - `failed` → red
- **Font:** Inter (Next.js default)
- **Layout:** Sidebar (240px) + main content area
- **Mobile:** Sidebar collapses to bottom nav on mobile

---

## 19. Error Handling Rules

- All API routes must return consistent error format: `{ error: string }`
- All service functions must throw descriptive errors (not swallow them)
- UI must show toast on every action (success and failure) using Sonner
- Webhook route must always return 200 (even on error) to prevent Overseerr retrying
- BigInt from Prisma must be serialized to string before JSON response

---

## 20. Security Checklist

- [ ] Webhook endpoint validates `WEBHOOK_SECRET` header
- [ ] All other API routes check `auth()` session
- [ ] Passwords hashed with bcrypt (cost factor 12)
- [ ] No API keys exposed to client-side code (all service calls server-side only)
- [ ] Input validated with Zod on all POST endpoints
- [ ] Rate limit webhook endpoint (max 10 req/min per IP) using `@upstash/ratelimit` or simple in-memory map

---

## 21. Definition of Done

The app is considered production-ready when:

- [ ] Overseerr webhook received and stored in DB
- [ ] Prowlarr search returns results in UI
- [ ] User can select a torrent and it appears in qBittorrent
- [ ] Download progress visible in UI (polling)
- [ ] Radarr/Sonarr notified on completion
- [ ] Login/logout works
- [ ] Docker Compose starts cleanly with `docker compose up -d`
- [ ] All env vars documented in `.env.example`
- [ ] README with setup instructions
- [ ] No TypeScript errors (`tsc --noEmit` passes)
- [ ] No `any` types except where absolutely necessary

---

*Build Pickrr. Fill the gap. Open source it.*
